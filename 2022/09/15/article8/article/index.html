<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>你不知道的JavaScript（上）——this和对象原型 | 欢迎来玩~~</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="第一章 关于this this 并不像我们所想的那样指向函数本身。看这个例子：">
<meta property="og:type" content="article">
<meta property="og:title" content="你不知道的JavaScript（上）——this和对象原型">
<meta property="og:url" content="http://example.com/2022/09/15/article8/article/index.html">
<meta property="og:site_name" content="欢迎来玩~~">
<meta property="og:description" content="第一章 关于this this 并不像我们所想的那样指向函数本身。看这个例子：">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-09-15T14:00:49.000Z">
<meta property="article:modified_time" content="2022-09-15T14:10:37.602Z">
<meta property="article:author" content="Zheng">
<meta property="article:tag" content="this、原型、原型链">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="欢迎来玩~~" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
<meta name="generator" content="Hexo 5.4.0"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
				<img lazy-src="/img/avatar.jpg" class="js-avatar">
			
		</a>

		<hgroup>
			<h1 class="header-author"><a href="/">Zheng</a></h1>
		</hgroup>

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">Home</a></li>
				        
							<li><a href="/archives">Archives</a></li>
				        
						</ul>
					</nav>
					<nav class="half-header-menu">
						<a class="hide">Home</a>
						<a>Tags</a>
						<a>Links</a>
						<a>About</a>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
						<!-- music -->
						
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Hexo%E5%9B%BE%E7%89%87/" style="font-size: 10px;">Hexo图片</a> <a href="/tags/Vue%E3%80%81%E8%99%9A%E6%8B%9FDOM/" style="font-size: 10px;">Vue、虚拟DOM</a> <a href="/tags/http%E7%BC%93%E5%AD%98/" style="font-size: 10px;">http缓存</a> <a href="/tags/this%E3%80%81%E5%8E%9F%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE/" style="font-size: 10px;">this、原型、原型链</a> <a href="/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E9%97%AD%E5%8C%85%E3%80%81RHS%E3%80%81LHS/" style="font-size: 10px;">作用域、闭包、RHS、LHS</a> <a href="/tags/%E5%AE%9A%E6%97%B6%E5%99%A8/" style="font-size: 10px;">定时器</a> <a href="/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/" style="font-size: 10px;">构造函数</a> <a href="/tags/%E9%98%B2%E6%8A%96%E3%80%81%E8%8A%82%E6%B5%81/" style="font-size: 10px;">防抖、节流</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/">github</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">科软在读，欢迎交流~</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/avatar.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author"></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">Home</a></li>
		        
					<li><a href="/archives">Archives</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-article8/article" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/09/15/article8/article/" class="article-date">
  	<time datetime="2022-09-15T14:00:49.000Z" itemprop="datePublished">2022-09-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      你不知道的JavaScript（上）——this和对象原型
      
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/this%E3%80%81%E5%8E%9F%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE/" rel="tag">this、原型、原型链</a></li></ul>
	</div>

        

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="第一章-关于this"><a href="#第一章-关于this" class="headerlink" title="第一章 关于this"></a>第一章 关于this</h2><ul>
<li>this 并不像我们所想的那样指向函数本身。看这个例子：</li>
</ul>
<span id="more"></span>

<pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function foo(num) &#123;</span><br><span class="line">    console.log( &quot;foo: &quot; + num );</span><br><span class="line">    // 记录 foo 被调用的次数</span><br><span class="line">    this.count++;</span><br><span class="line">&#125;</span><br><span class="line">foo.count = 0;</span><br><span class="line">var i;</span><br><span class="line">for (i=0; i&lt;10; i++) &#123;</span><br><span class="line">    if (i &gt; 5) &#123;</span><br><span class="line">        foo( i );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// foo: 6</span><br><span class="line">// foo: 7</span><br><span class="line">// foo: 8</span><br><span class="line">// foo: 9</span><br><span class="line">// foo 被调用了多少次？</span><br><span class="line">console.log( foo.count ); // 0</span><br></pre></td></tr></table></figure>
这段代码在无意中创建了一个全局变量 `count`，它的值为 `NaN`。因为在这里，`this`指向了全局对象`window`，为它创建了一个属性`count`，值为`undefined`，而`undefined + 1 = NaN`。
</code></pre>
<ul>
<li>还有一种传统的但是现在已经被弃用和批判的用法，是使用 <code>arguments.callee</code> 来引用当前正在运行的函数对象。<code>arguments.callee</code> 已经被弃用，不应该再使用它。</li>
<li>this 在任何情况下都不指向函数的词法作用域。</li>
<li> this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。</li>
</ul>
<h2 id="第二章-this全面解析"><a href="#第二章-this全面解析" class="headerlink" title="第二章 this全面解析"></a>第二章 this全面解析</h2><h4 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h4><p>思考这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line">var a = 2;</span><br><span class="line">foo(); // 2</span><br></pre></td></tr></table></figure>
<p>在代码中，foo()是直接使用不带任何修饰的函数引用进行调用的，结果也相当于<code>window.foo()</code>，因此在函数内部，<code>this</code>也就指向调用函数的对象<code>window</code>，这就是默认绑定。<br>如果使用严格模式（strict mode），那么全局对象将无法使用默认绑定（严格模式下禁止<code>this</code>指向全局对象），因此 this 会绑定到 undefined：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    &quot;use strict&quot;;</span><br><span class="line">    console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line">var a = 2;</span><br><span class="line">foo(); // TypeError: this is undefined</span><br></pre></td></tr></table></figure>
<h4 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h4><p>思考下面代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    a: 2,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line">obj.foo(); // 2</span><br></pre></td></tr></table></figure>
<p>当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。因为调用 foo() 时 this 被绑定到 obj，因此 this.a 和 obj.a 是一样的。</p>
<h4 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h4><p>一个最常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把 this 绑定到全局对象或者 undefined 上，取决于是否是严格模式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    a: 2,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line">var bar = obj.foo; // 函数别名！</span><br><span class="line">var a = &quot;oops, global&quot;; // a 是全局对象的属性</span><br><span class="line">bar(); // &quot;oops, global&quot;</span><br></pre></td></tr></table></figure>
<h4 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h4><p>顾名思义，就是使用<code>call</code>和<code>apply</code>这两个函数显式绑定。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    a:2</span><br><span class="line">&#125;;</span><br><span class="line">foo.call( obj ); // 2</span><br></pre></td></tr></table></figure>
<p>如果你传入了一个原始值（字符串类型、布尔类型或者数字类型）来当作 this 的绑定对象，这个原始值会被转换成它的对象形式（也就是 new String(..)、new Boolean(..) 或者<br>new Number(..)）。这通常被称为“装箱”。</p>
<h4 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h4><p>包括内置对象函数在内的<strong>所有函数</strong>都可以用 new 来调用，这种函数调用被称为构造函数调用。这里有一个重要但是非常细微的区别：实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。</p>
<h4 id="间接引用"><a href="#间接引用" class="headerlink" title="间接引用"></a>间接引用</h4><p>有可能（有意或者无意地）创建一个函数的“间接引用”，在这种情况下，调用这个函数会应用默认绑定规则。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line">var a = 2;</span><br><span class="line">var o = &#123; a: 3, foo: foo &#125;;</span><br><span class="line">var p = &#123; a: 4 &#125;;</span><br><span class="line">o.foo(); // 3</span><br><span class="line">(p.foo = o.foo)(); // 2</span><br></pre></td></tr></table></figure>
<p>赋值表达式 <code>p.foo = o.foo</code> 的返回值是目标函数的引用，因此调用位置是 foo() 而不是p.foo() 或者 o.foo()。<br>注意：对于默认绑定来说，决定 this 绑定对象的并不是调用位置是否处于严格模式，而是<strong>函数体是否处于严格模式</strong>。如果函数体处于严格模式，<code>this</code> 会被绑定到<code> undefined</code>，否则 <code>this</code> 会被绑定到全局对象。</p>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>箭头函数不使用 this 的四种标准规则，而是根据外层（函数或者全局）作用域来决定 this。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    // 返回一个箭头函数</span><br><span class="line">    return (a) =&gt; &#123;</span><br><span class="line">        //this 继承自 foo()</span><br><span class="line">        console.log( this.a );</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var obj1 = &#123;</span><br><span class="line">    a:2</span><br><span class="line">&#125;;</span><br><span class="line">var obj2 = &#123;</span><br><span class="line">    a:3</span><br><span class="line">&#125;;</span><br><span class="line">var bar = foo.call( obj1 );</span><br><span class="line">bar.call( obj2 ); // 2, 不是 3 ！</span><br></pre></td></tr></table></figure>
<p>foo() 内部创建的箭头函数会捕获调用时 foo() 的 this。箭头函数的绑定无法被修改，new也不行。</p>
<h2 id="第三章-对象"><a href="#第三章-对象" class="headerlink" title="第三章 对象"></a>第三章 对象</h2><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p>原始值 “I am a string” 并不是一个对象，它只是一个字面量，并且是一个不可变的值。如果要在这个字面量上执行一些操作，比如获取长度、访问其中某个字符等，那需要将其转换为 String 对象。同样的事也会发生在数值字面量上，如果使用类似<code> 42.359.toFixed(2)</code> 的方法，引擎会把42 转换成 <code>new Number(42)</code>。对于布尔字面量来说也是如此。<br>Error 对象很少在代码中显式创建，一般是在抛出异常时被自动创建。</p>
<h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><p>. 操作符或者 [] 操作符都可以用来访问对象的属性。这两种语法的主要区别在于 . 操作符要求属性名满足标识符的命名规范，而 [“..”] 语法可以接受任意 UTF-8/Unicode 字符串作为属性名。举例来说，如果要引用名称为 <code>&quot;Super·Fun!&quot;</code> 的属性，那就必须使用 <code>[&quot;Super-Fun!&quot;]</code> 语法访问，因为 <code>Super-Fun!</code> 并不是一个有效的标识符属性名。<br>注意：在对象中，属性名永远都是字符串。</p>
<h4 id="对象拷贝："><a href="#对象拷贝：" class="headerlink" title="对象拷贝："></a>对象拷贝：</h4><p>深拷贝有一种简单的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var newObj = JSON.parse( JSON.stringify( someObj ) );</span><br></pre></td></tr></table></figure>
<p>但是这种方法对Date、RegExp、undefined、Error、函数无效。<br>浅拷贝也有现成的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var newObj = Object.assign( &#123;&#125;, myObject );</span><br></pre></td></tr></table></figure>
<p>Object.assign(..) 方法的第一个参数是目标对象，之后还可以跟一个或多个源对象。它会遍历一个或多个源对象的所有可枚举的自有键并把它们复制（使用 = 操作符赋值）到目标对象，最后返回目标对象。</p>
<h4 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h4><p>看看这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">    a:2</span><br><span class="line">&#125;;</span><br><span class="line">Object.getOwnPropertyDescriptor( myObject, &quot;a&quot; );</span><br><span class="line">// &#123;</span><br><span class="line">// value: 2,</span><br><span class="line">// writable: true,</span><br><span class="line">// enumerable: true,</span><br><span class="line">// configurable: true</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure>
<p>这描述了每个属性的描述符。在创建普通属性时属性描述符会使用默认值，我们也可以使用 <code>Object.defineProperty(..)</code><br>来添加一个新属性或者修改一个已有属性（如果它是 configurable）并对特性进行设置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;&#125;;</span><br><span class="line">Object.defineProperty( myObject, &quot;a&quot;, &#123;</span><br><span class="line">    value: 2,</span><br><span class="line">    writable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    enumerable: true</span><br><span class="line">&#125; );</span><br><span class="line">myObject.a; // 2</span><br></pre></td></tr></table></figure>
<p>如 果 你 想 禁 止 一 个 对 象 添 加 新 属 性 并 且 保 留 已 有 属 性， 可 以 使 用 <code>Object.preventExtensions(..)</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">    a:2</span><br><span class="line">&#125;;</span><br><span class="line">Object.preventExtensions( myObject );</span><br><span class="line">myObject.b = 3;</span><br><span class="line">myObject.b; // undefined</span><br></pre></td></tr></table></figure>
<p>在非严格模式下，创建属性 b 会静默失败。在严格模式下，将会抛出 TypeError 错误。<br>Object.seal(..) 会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用Object.preventExtensions(..) 并把所有现有属性标记为 configurable:false。<br>所以，密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性（虽然可以修改属性的值）。</p>
<h4 id="Get"><a href="#Get" class="headerlink" title="[[Get]]"></a>[[Get]]</h4><p>对象默认的内置 [[Get]] 操作首先在对象中查找是否有名称相同的属性，如果找到就会返回这个属性的值。然而，如果没有找到名称相同的属性，按照 [[Get]] 算法的定义会遍历可能存在的原型链。如果无论如何都没有找到名称相同的属性，那 [[Get]] 操作会返回值 undefined。这种方法和访问变量时是不一样的。如果你引用了一个当前词法作用域中不存在的变量，并不会像对象属性一样返回 undefined，而是会抛出一个 ReferenceError 异常。这就是第一章讲到的RHS。</p>
<h4 id="存在性"><a href="#存在性" class="headerlink" title="存在性"></a>存在性</h4><p>访问一个对象的属性值返回了undefined，可能是因为该对象不存在这个属性，也有可能是因为这个属性的值就是存储为undefined。该如何区分这两种情况？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">    a:2</span><br><span class="line">&#125;;</span><br><span class="line">(&quot;a&quot; in myObject); // true</span><br><span class="line">(&quot;b&quot; in myObject); // false</span><br><span class="line">myObject.hasOwnProperty( &quot;a&quot; ); // true</span><br><span class="line">myObject.hasOwnProperty( &quot;b&quot; ); // false</span><br></pre></td></tr></table></figure>
<p>in 操作符会检查属性是否在对象及其 [[Prototype]] 原型链中。hasOwnProperty(..) 只会检查属性是否在 myObject 对象中，不会检查 [[Prototype]] 链。<br>++其实我以前自己写深拷贝的时候，经常喜欢用<code>for...in</code>来遍历对象的属性，但是看到了这里还是感觉用<code>hasOwnProperty</code>更加合理，因为有些属性可能被设置为不可枚举，用<code>for...in</code>就遍历不到了。++<br>对于<code>in</code>操作符还有一个细节需要十分注意（注意这里说的并不是<code>for...in</code>）。那就是in 操作符可以检查容器内是否有某个值，但是它实际上检查的是某个属性名是否存在。用在数组上，<code>4 in [2, 4, 6]</code> 的结果并不是期待的 True，因为 [2, 4, 6] 这个数组中包含的属性名是 0、1、2，没有 4。</p>
<h2 id="第四章-混合对象“类”"><a href="#第四章-混合对象“类”" class="headerlink" title="第四章 混合对象“类”"></a>第四章 混合对象“类”</h2><p>JavaScript是不支持多重继承的，因为多重继承可能会存在很多严重的问题。比如子类C继承自父类A和B，如果A和B都含有方法<code>tool()</code>,那么子类引用的究竟是哪一个？</p>
<h4 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h4><p>首先看看显式混入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 非常简单的 mixin(..) 例子 :</span><br><span class="line">function mixin( sourceObj, targetObj ) &#123;</span><br><span class="line">    for (var key in sourceObj) &#123;</span><br><span class="line">        // 只会在不存在的情况下复制</span><br><span class="line">        if (!(key in targetObj)) &#123;</span><br><span class="line">            targetObj[key] = sourceObj[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return targetObj;</span><br><span class="line">&#125;</span><br><span class="line">var Vehicle = &#123;</span><br><span class="line">    engines: 1,</span><br><span class="line">    ignition: function() &#123;</span><br><span class="line">        console.log( &quot;Turning on my engine.&quot; );</span><br><span class="line">    &#125;,</span><br><span class="line">    drive: function() &#123;</span><br><span class="line">        this.ignition();</span><br><span class="line">        console.log( &quot;Steering and moving forward!&quot; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var Car = mixin( Vehicle, &#123;</span><br><span class="line">    wheels: 4,</span><br><span class="line">    drive: function() &#123;</span><br><span class="line">        Vehicle.drive.call( this );</span><br><span class="line">        console.log(&quot;Rolling on all &quot; + this.wheels + &quot; wheels!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>这种方式对于函数并不是真正的复制，而是引用，所以可能会导致数据不一致性的问题。<br>显式混入是 JavaScript 中一个很棒的机制，不过它的功能也没有看起来那么强大。虽然它可以把一个对象的属性复制到另一个对象中，但是这其实并不能带来太多的好处，无非就是少几条定义语句，而且还会带来我们刚才提到的函数对象引用问题。</p>
<h2 id="第五章-原型"><a href="#第五章-原型" class="headerlink" title="第五章 原型"></a>第五章 原型</h2><p>使用 for..in 遍历对象时原理和查找 [[Prototype]] 链类似，任何可以通过原型链访问到的属性都会被枚举。<br>所有普通的 [[Prototype]] 链最终都会指向内置的 Object.prototype。由于所有的“普通”<br>（内置，不是特定主机的扩展）对象都“源于”（或者说把 [[Prototype]] 链的顶端设置为）这个 Object.prototype 对象，所以它包含 JavaScript 中许多通用的功能。比 如 说 .toString() 和 .valueOf()等。<br>下面我们分析一下如果 foo 不直接存在于 myObject 中而是存在于原型链上层时 myObject.foo = “bar” 会出现的三种情况。</p>
<ul>
<li>如果在 [[Prototype]] 链上层存在名为 foo 的普通数据访问属性（参见第 3 章）并且没有被标记为只读（writable:false），那就会直接在 myObject 中添加一个名为 foo 的新属性，它是屏蔽属性。</li>
<li>如果在 [[Prototype]] 链上层存在 foo，但是它被标记为<strong>只读</strong>（writable:false），那么无法修改已有属性或者在 myObject 上创建屏蔽属性。如果运行在严格模式下，代码会抛出一个错误。否则，这条赋值语句会被忽略。总之，不会发生屏蔽。</li>
<li> 如果在 [[Prototype]] 链上层存在 foo 并且它是一个 setter（参见第 3 章），那就一定会调用这个 setter。foo 不会被添加到（或者说屏蔽于）myObject，也不会重新定义 foo 这个 setter。<br>有些情况下会隐式产生屏蔽，一定要当心：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var anotherObject = &#123;</span><br><span class="line">    a:2</span><br><span class="line">&#125;;</span><br><span class="line">var myObject = Object.create( anotherObject );</span><br><span class="line">anotherObject.a; // 2</span><br><span class="line">myObject.a; // </span><br><span class="line"></span><br><span class="line">anotherObject.hasOwnProperty( &quot;a&quot; ); // true</span><br><span class="line">myObject.hasOwnProperty( &quot;a&quot; ); // false</span><br><span class="line"></span><br><span class="line">myObject.a++; // 隐式屏蔽！</span><br><span class="line">anotherObject.a; // 2</span><br><span class="line">myObject.a; // 3</span><br><span class="line">myObject.hasOwnProperty( &quot;a&quot; ); // true</span><br></pre></td></tr></table></figure>
尽管 myObject.a++ 看起来应该（通过委托）查找并增加 anotherObject.a 属性，但是别忘了 ++ 操作相当于 myObject.a = myObject.a + 1。因此 ++ 操作首先会通过 [[Prototype]]<br>查找属性 a 并从 anotherObject.a 获取当前属性值 2，然后给这个值加 1，接着用 [[Put]]将值 3 赋给 myObject 中新建的屏蔽属性 a，天呐！如果想让 anotherObject.a 的值增加，唯一的办法是<code>anotherObject.a++</code>。</li>
</ul>
<p>new Foo() 会生成一个新对象（我们称之为 a），这个新对象的内部链接 [[Prototype]] 关联的是 Foo.prototype 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line">var a = new Foo();</span><br><span class="line">Object.getPrototypeOf( a ) === Foo.prototype; // true</span><br></pre></td></tr></table></figure>
<p>Foo.prototype 默认（在代码中第一行声明时！）有一个公有并且不可枚举的属性 .constructor，这个属性引用的是对象关联的函数（本例中是 Foo）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.constructor === Foo; // true</span><br><span class="line">var a = new Foo();</span><br><span class="line">a.constructor === Foo; // true</span><br></pre></td></tr></table></figure>
<p>实际上，Foo 和你程序中的其他函数没有任何区别。函数本身并不是构造函数，然而，当你在普通的函数调用前面加上 new 关键字之后，就会把这个函数调用变成一个“构造函数调用”。实际上，new 会劫持所有普通函数并用构造对象的形式来调用它。<br>a.constructor 只是通过默认的 [[Prototype]] 委托指向 Foo，这和“构造”毫无关系。举例来说，Foo.prototype 的 .constructor 属性只是 Foo 函数在声明时的默认属性。如果你创建了一个新对象并替换了函数默认的 .prototype 对象引用，那么新对象并不会自动获得 .constructor 属性。这也就是为什么我们在实现继承时还需要手动修正constructor指向。思考这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123; /* .. */ &#125;</span><br><span class="line">Foo.prototype = &#123; /* .. */ &#125;; // 创建一个新原型对象</span><br><span class="line">var a1 = new Foo();</span><br><span class="line">a1.constructor === Foo; // false!</span><br><span class="line">a1.constructor === Object; // true!</span><br></pre></td></tr></table></figure>
<p>a1 并没有 .constructor 属性，所以它会委托 [[Prototype]] 链上的 Foo.<br>prototype。但是这个对象也没有 .constructor 属性（不过默认的 Foo.prototype 对象有这个属性！），所以它会继续委托，这次会委托给委托链顶端的 Object.prototype。这个对象有 .constructor 属性，指向内置的 Object(..) 函数。<br>如何修复.constructor?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123; /* .. */ &#125;</span><br><span class="line">Foo.prototype = &#123; /* .. */ &#125;; // 创建一个新原型对象</span><br><span class="line">// 需要在 Foo.prototype 上“修复”丢失的 .constructor 属性</span><br><span class="line">// 新对象属性起到 Foo.prototype 的作用</span><br><span class="line">// 关于 defineProperty(..)，参见第 3 章</span><br><span class="line">Object.defineProperty( Foo.prototype, &quot;constructor&quot; , &#123;</span><br><span class="line">    enumerable: false,</span><br><span class="line">    writable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    value: Foo // 让 .constructor 指向 Foo</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<h4 id="检查“类”关系"><a href="#检查“类”关系" class="headerlink" title="检查“类”关系"></a>检查“类”关系</h4><p>在传统的面向类环境中，检查一个实例（JavaScript 中的对象）的继承祖先（JavaScript 中的委托关联）通常被称为内省（或者反射）。<br>如果要判断一个实例是否由某个函数构造来，可以使用<code>instanceof</code>来判断。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a instanceof Foo;</span><br></pre></td></tr></table></figure>
<p>instanceof 回答的问题是：在 a 的整条 [[Prototype]] 链中是否有指向 Foo.prototype 的对象？</p>
<h4 id="创建关联"><a href="#创建关联" class="headerlink" title="创建关联"></a>创建关联</h4><p>Object.create(..) 是在 ES5 中新增的函数，所以在 ES5 之前的环境中（比如旧 IE）如果要支持这个功能的话就需要使用一段简单的 polyfill 代码，它部分实现了 Object.create(..) 的功能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (!Object.create) &#123;</span><br><span class="line">    Object.create = function(o) &#123;</span><br><span class="line">        function F()&#123;&#125;</span><br><span class="line">        F.prototype = o;</span><br><span class="line">        return new F();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2022/09/04/article7/article/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">你不知道的JavaScript（上）——作用域与闭包</div>
      <strong class="article-nav-caption">&gt;</strong>
    </a>
  
</nav>

  
</article>






</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2022 Zheng
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/preccrep/hexo-theme-jelly" target="_blank">Jelly</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/js/main.js"></script>




  </div>
</body>
</html>